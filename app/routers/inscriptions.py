# app/routers/inscriptions.py
from __future__ import annotations

import os
from datetime import date as _date, datetime, timezone
from typing import Optional

from fastapi import APIRouter, Depends, Form, HTTPException, Query, Request, UploadFile, File
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from sqlmodel import Session, select
from sqlalchemy import func

from app_lia_web.core.database import get_session
from app_lia_web.core.config import settings
from app_lia_web.core.security import get_current_user
from app_lia_web.core.path_config import path_config
from app_lia_web.core.program_schema_integration import (
    get_program_schema_from_request,
    get_schema_routing_service,
    SchemaRoutingService
)
from app_lia_web.app.services.file_upload_service import FileUploadService
from app_lia_web.app.templates import templates

from app_lia_web.app.models.base import (
    Programme, Candidat, Entreprise, Preinscription, Eligibilite,
    Inscription, EtapePipeline, AvancementEtape, StatutEtape,
    DecisionJuryTable, Jury, DecisionJuryCandidat, Partenaire, User, Promotion, Groupe,
    ReorientationCandidat, Document
)
from app_lia_web.app.models.enums import TypeDocument, DecisionJury, UserRole, GroupeCodev, TypePromotion
from app_lia_web.app.services.ACD.eligibilite import evaluate_eligibilite, entreprise_age_annees
from app_lia_web.app.services.ACD.service_qpv import verif_qpv
from app_lia_web.app.services.ACD.service_siret_pappers import get_entreprise_process
from app_lia_web.app.schemas.ACD.schema_qpv import Adresse
from app_lia_web.app.schemas.ACD.schema_siret import SiretRequest

router = APIRouter()

def _prog_by_code(session: Session, code: str) -> Programme | None:
    return session.exec(select(Programme).where(Programme.code == code)).first()

@router.get("/form", name="form_inscriptions_display", response_class=HTMLResponse)
def inscriptions_ui(
    request: Request,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
    programme: str = Query("ACD"),
    q: Optional[str] = Query(None),
    pre_id: Optional[int] = Query(None),
):
    prog = _prog_by_code(session, programme)
    if not prog:
        # Au lieu de lever une erreur, cr√©er un programme factice avec des valeurs vides
        class ProgrammeFactice:
            def __init__(self):
                self.id = None
                self.code = programme
                self.nom = f"Programme {programme} (non trouv√©)"
        
        prog = ProgrammeFactice()

    # Liste de pr√©inscriptions (colonnes pour la liste gauche)
    pre_rows = []
    if prog.id:
        stmt = (
            select(Preinscription, Candidat, Entreprise, Eligibilite)
            .join(Candidat, Candidat.id==Preinscription.candidat_id)
            .join(Entreprise, Entreprise.candidat_id==Candidat.id, isouter=True)
            .join(Eligibilite, Eligibilite.preinscription_id==Preinscription.id, isouter=True)
            .where(Preinscription.programme_id==prog.id)
        )
        if q:
            like = f"%{q}%"
            stmt = stmt.where((Candidat.nom.ilike(like)) | (Candidat.prenom.ilike(like)) | (Candidat.email.ilike(like)))
        pre_rows = session.exec(stmt.order_by(Preinscription.cree_le.desc()).limit(400)).all()
        
        # Debug logs
        if settings.DEBUG:
            print(f"üîç [DEBUG] Programme ID: {prog.id}")
            print(f"üìä [DEBUG] Nombre de pr√©inscriptions trouv√©es: {len(pre_rows)}")
            for i, row in enumerate(pre_rows[:3]):  # Afficher les 3 premi√®res
                p, c, e, elig = row
                print(f"   {i+1}. Pr√©inscription ID: {p.id}, Candidat: {c.nom} {c.prenom}")
                print(f"      üì∏ Photo profil: {repr(c.photo_profil)}")
                if c.photo_profil:
                    print(f"      üîó URL g√©n√©r√©e: /media/{c.photo_profil}")

    selected = None; cand=None; ent=None; elig=None; inscription=None; pipeline=[]
    if pre_id:
        if settings.DEBUG:
            print(f"üéØ [DEBUG] Recherche de pr√©inscription ID: {pre_id}")
        for row in pre_rows:
            if row[0].id == pre_id:
                selected, cand, ent, elig = row
                if settings.DEBUG:
                    print(f"‚úÖ [DEBUG] Pr√©inscription trouv√©e: {selected.id}, Candidat: {cand.nom} {cand.prenom}")
                break
        
        if not selected and settings.DEBUG:
            print(f"‚ùå [DEBUG] Pr√©inscription ID {pre_id} non trouv√©e dans la liste")
            print(f"üìã [DEBUG] IDs disponibles: {[row[0].id for row in pre_rows]}")
        
        if selected:
            inscription = session.exec(
                select(Inscription).where(
                    (Inscription.programme_id==prog.id) & (Inscription.candidat_id==cand.id)
                )
            ).first()
            if inscription:
                # Pipeline (avancement attach√©)
                av = session.exec(
                    select(AvancementEtape).where(AvancementEtape.inscription_id==inscription.id)
                    .join(EtapePipeline).order_by(EtapePipeline.ordre)
                ).all()
                pipeline = [{"id": a.id, "statut": a.statut, "etape": a.etape, "debut": a.debut_le, "fin": a.termine_le} for a in av]

    # KPI simples
    total_pre = 0
    total_insc = 0
    taux_conv = 0.0
    objectif_qpv_atteint = 0.0
    
    if prog.id:
        total_pre = session.exec(select(func.count(Preinscription.id)).where(Preinscription.programme_id==prog.id)).one() or 0
        total_insc = session.exec(select(func.count(Inscription.id)).where(Inscription.programme_id==prog.id)).one() or 0
        taux_conv = round((total_insc / total_pre * 100), 1) if total_pre else 0.0

        # Objectif QPV (ex: % de pr√©inscrits ayant qpv_ok)
        qpv_ok_count = session.exec(
            select(func.count(Eligibilite.id)).join(Preinscription).where(
                (Preinscription.programme_id==prog.id) & (Eligibilite.qpv_ok.is_(True))
            )
        ).one() or 0
        objectif_qpv_atteint = round((qpv_ok_count / total_pre * 100), 1) if total_pre else 0.0

    # Jury sessions futures + r√©centes
    jurys = []
    if prog.id:
        jurys = session.exec(select(Jury).where(Jury.programme_id==prog.id).order_by(Jury.session_le.desc())).all()

    # Donn√©es pour le syst√®me de d√©cisions du jury
    decisions_jury = []
    conseillers = []
    promotions = []
    partenaires = []
    
    if cand:
        # R√©cup√©rer les d√©cisions du jury pour ce candidat avec les relations
        from sqlalchemy.orm import joinedload
        decisions_jury = session.exec(
            select(DecisionJuryCandidat)
            .options(
                joinedload(DecisionJuryCandidat.jury),
                joinedload(DecisionJuryCandidat.conseiller),
                joinedload(DecisionJuryCandidat.groupe),
                joinedload(DecisionJuryCandidat.promotion),
                joinedload(DecisionJuryCandidat.partenaire)
            )
            .where(DecisionJuryCandidat.candidat_id == cand.id)
            .order_by(DecisionJuryCandidat.date_decision.desc())
        ).all()
    
    # R√©cup√©rer les conseillers
    conseillers = session.exec(select(User).where(User.role == UserRole.CONSEILLER.value)).all()
    
    # R√©cup√©rer les promotions
    promotions = session.exec(select(Promotion)).all()
    
    # R√©cup√©rer les partenaires actifs
    partenaires = session.exec(select(Partenaire).where(Partenaire.actif == True)).all()
    
    # R√©cup√©rer les groupes actifs
    groupes = session.exec(select(Groupe).where(Groupe.actif == True).order_by(Groupe.nom)).all()

    # Extraire le nom du QPV si disponible
    qpv_name = None
    if elig and elig.details_json:
        try:
            import json
            qpv_details = json.loads(elig.details_json)
            if qpv_details.get("adresses_analysees"):
                for analyse in qpv_details["adresses_analysees"]:
                    if analyse.get("resultat") and analyse["resultat"].get("nom_qp"):
                        nom_qp = analyse["resultat"]["nom_qp"]
                        if "QPV:" in nom_qp or "QPV limit:" in nom_qp:
                            qpv_name =nom_qp # nom_qp.split(":")[1] if ":" in nom_qp else nom_qp
                            break
        except (json.JSONDecodeError, KeyError, IndexError):
            qpv_name = None

    return templates.TemplateResponse(
        "programme/inscription.html",
        {
            "request": request,
            "settings": settings,
            "utilisateur": current_user,
            "current_programme": programme,
            "q": q or "",
            "pre_rows": pre_rows,
            "selected": selected,
            "programme": prog,
            "cand": cand,
            "ent": ent,
            "elig": elig,
            "inscription": inscription,
            "pipeline": pipeline,
            "jurys": jurys,
            "decisions_jury": decisions_jury,
            "conseillers": conseillers,
            "promotions": promotions,
            "partenaires": partenaires,
            "qpv_name": qpv_name,
            "type_documents": TypeDocument,
            "groupes": groupes,
            "type_promotion_enum": TypePromotion,
            "kpi": {
                "total_pre": int(total_pre),
                "total_insc": int(total_insc),
                "taux_conv": taux_conv,
                "objectif_qpv_atteint": objectif_qpv_atteint,
            },
            "timestamp": int(datetime.now().timestamp()),
        }
    )


# Cr√©e une inscription √† partir d'une pr√©inscription
@router.post("/create-from-pre", name="create_inscription_from_preinscription")
def create_from_pre(
    request: Request,
    pre_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    pre = session.get(Preinscription, pre_id)
    if not pre:
        raise HTTPException(status_code=404, detail="Pr√©inscription introuvable")
    prog = session.get(Programme, pre.programme_id)
    if not prog:
        raise HTTPException(status_code=404, detail="Programme introuvable")
    exists = session.exec(
        select(Inscription).where(
            (Inscription.programme_id==pre.programme_id) & (Inscription.candidat_id==pre.candidat_id)
        )
    ).first()
    if exists:
        return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&pre_id={pre.id}", status_code=303)

    ins = Inscription(programme_id=pre.programme_id, candidat_id=pre.candidat_id, statut=pre.statut)
    session.add(ins); session.flush()

    # Instancie le pipeline pour ce programme
    steps = session.exec(
        select(EtapePipeline).where(
            (EtapePipeline.programme_id==prog.id) & (EtapePipeline.active.is_(True))
        ).order_by(EtapePipeline.ordre)
    ).all()
    for st in steps:
        av = AvancementEtape(inscription_id=ins.id, etape_id=st.id, statut=StatutEtape.A_FAIRE)
        session.add(av)

    session.commit()
    return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&pre_id={pre.id}", status_code=303)


# Mise √† jour infos candidat/entreprise
@router.post("/update-infos", name="update_infos_inscription")
async def update_infos(
    request: Request,
    pre_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    # Informations personnelles
    civilite: Optional[str] = Form(None),
    date_naissance: Optional[str] = Form(None),
    telephone: Optional[str] = Form(None),
    adresse_personnelle: Optional[str] = Form(None),
    niveau_etudes: Optional[str] = Form(None),
    secteur_activite: Optional[str] = Form(None),
    handicap: Optional[str] = Form(None),
    # Photo de profil
    photo_profil: UploadFile | None = File(None),
    # Informations entreprise
    siret: Optional[str] = Form(None),
    siren: Optional[str] = Form(None),
    raison_sociale: Optional[str] = Form(None),
    code_naf: Optional[str] = Form(None),
    date_creation: Optional[str] = Form(None),
    adresse_entreprise: Optional[str] = Form(None),
    chiffre_affaires: Optional[str] = Form(None),
    nombre_points_vente: Optional[str] = Form(None),
    # Informations restauration
    specialite_culinaire: Optional[str] = Form(None),
    nom_concept: Optional[str] = Form(None),
    site_internet: Optional[str] = Form(None),
    lien_reseaux_sociaux: Optional[str] = Form(None),
    # Informations g√©ographiques
    qpv: Optional[str] = Form(None),
    lat: Optional[str] = Form(None),
    lng: Optional[str] = Form(None),
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    pre = session.get(Preinscription, pre_id)
    if not pre:
        raise HTTPException(status_code=404, detail="Pr√©inscription introuvable")
    cand = session.get(Candidat, pre.candidat_id)
    # Charger les documents du candidat
    if cand:
        from app_lia_web.app.models.base import Document
        cand.documents = session.exec(select(Document).where(Document.candidat_id == cand.id)).all()
        print(f"üìã [INSCRIPTION] Documents charg√©s pour candidat {cand.id}: {len(cand.documents)} documents")
        for doc in cand.documents:
            print(f"   - {doc.nom_fichier} ({doc.type_document})")
        
        # V√©rification suppl√©mentaire : tous les documents en base pour ce candidat
        all_docs = session.exec(select(Document).where(Document.candidat_id == cand.id)).all()
        print(f"üîç [INSCRIPTION] V√©rification directe en base: {len(all_docs)} documents trouv√©s")
        for doc in all_docs:
            print(f"   - ID: {doc.id}, Nom: {doc.nom_fichier}, Type: {doc.type_document}")
    ent = session.exec(select(Entreprise).where(Entreprise.candidat_id==cand.id)).first()
    if not ent:
        ent = Entreprise(candidat_id=cand.id)
        session.add(ent); session.flush()

    # Mise √† jour des informations personnelles
    if civilite:
        cand.civilite = civilite
    if date_naissance:
        try:
            cand.date_naissance = _date.fromisoformat(date_naissance)
        except Exception:
            pass
    if telephone is not None:
        cand.telephone = telephone
    if adresse_personnelle is not None:
        cand.adresse_personnelle = adresse_personnelle
    if niveau_etudes is not None:
        cand.niveau_etudes = niveau_etudes
    if secteur_activite is not None:
        cand.secteur_activite = secteur_activite
    cand.handicap = handicap == "true"
    
    # Mise √† jour de la photo de profil
    if photo_profil and photo_profil.filename:
        try:
            from app_lia_web.app.services.uploads import validate_upload
            from pathlib import Path
            import shutil
            
            # Validation du fichier
            validate_upload(
                photo_profil,
                allowed_mime_types=settings.ALLOWED_IMAGE_MIME_TYPES,
                max_mb=settings.MAX_UPLOAD_SIZE_MB,
                field_name="photo_profil",
            )
            
            # Supprimer l'ancienne photo si elle existe
            if cand.photo_profil:
                try:
                    FileUploadService.delete_file(cand.photo_profil)
                    if settings.DEBUG:
                        print(f"üóëÔ∏è [DEBUG] Ancienne photo supprim√©e: {cand.photo_profil}")
                except Exception as e:
                    if settings.DEBUG:
                        print(f"‚ö†Ô∏è [DEBUG] Erreur lors de la suppression de l'ancienne photo: {e}")
            
            # Cr√©er le dossier de destination
            prog = session.get(Programme, pre.programme_id)
            subfolder = f"Preinscrits/{prog.code or 'UNK'}/{pre.id}"
            
            # Nom de fichier unique avec ID de pr√©inscription
            ext = os.path.splitext(photo_profil.filename)[1].lower() or ".jpg"
            unique_filename = f"photo_profil_{pre.id}{ext}"
            
            # Utiliser FileUploadService pour sauvegarder le fichier
            file_info = await FileUploadService.save_file(
                photo_profil,
                "media",
                unique_filename,
                subfolder=subfolder
            )
            
            # Mettre √† jour le candidat avec le chemin relatif
            cand.photo_profil = file_info["relative_path"]
            
            if settings.DEBUG:
                print(f"üì∏ [DEBUG] Nouvelle photo sauvegard√©e: {file_info['relative_path']}")
                
        except Exception as e:
            if settings.DEBUG:
                print(f"‚ùå [DEBUG] Erreur sauvegarde photo: {e}")
            # On continue sans la photo
    
    if chiffre_affaires is not None:
        ent.chiffre_affaires = chiffre_affaires  # Maintenant c'est une string
    if nombre_points_vente is not None and nombre_points_vente.strip():
        try:
            ent.nombre_points_vente = int(nombre_points_vente)
        except (ValueError, TypeError):
            pass  # Ignorer les valeurs invalides
    
    # Mise √† jour des informations restauration
    if specialite_culinaire is not None:
        ent.specialite_culinaire = specialite_culinaire
    if nom_concept is not None:
        ent.nom_concept = nom_concept
    if site_internet is not None:
        ent.site_internet = site_internet
    if lien_reseaux_sociaux is not None:
        ent.lien_reseaux_sociaux = lien_reseaux_sociaux
    
    # Mise √† jour des informations g√©ographiques
    ent.qpv = qpv == "true"
    
    # Conversion s√©curis√©e des coordonn√©es GPS
    if lat is not None and lat.strip():
        try:
            cand.lat = float(lat)
        except (ValueError, TypeError):
            pass  # Ignorer les valeurs invalides
    if lng is not None and lng.strip():
        try:
            cand.lng = float(lng)
        except (ValueError, TypeError):
            pass  # Ignorer les valeurs invalides

    # Mise √† jour des informations entreprise
    if siret is not None:
        ent.siret = siret
    if siren is not None:
        ent.siren = siren
    if raison_sociale is not None:
        ent.raison_sociale = raison_sociale
    if code_naf is not None:
        ent.code_naf = code_naf
    if date_creation:
        try:
            ent.date_creation = _date.fromisoformat(date_creation)
        except Exception:
            pass
    if adresse_entreprise is not None:
        ent.adresse = adresse_entreprise

    session.commit()
    
    # Log de l'activit√©
    from app_lia_web.app.services.ACD.audit import log_activity
    log_activity(
        session=session,
        user=current_user,
        action="Mise √† jour informations candidat",
        entity="Candidat",
        entity_id=cand.id,
        activity_data={
            "preinscription_id": pre_id,
            "champs_modifies": [
                "civilite", "date_naissance", "telephone", "adresse_personnelle",
                "niveau_etudes", "secteur_activite", "handicap", "siret", "siren",
                "raison_sociale", "code_naf", "date_creation", "adresse_entreprise",
                "chiffre_affaires", "nombre_points_vente", "specialite_culinaire",
                "nom_concept", "site_internet", "lien_reseaux_sociaux", "qpv"
            ]
        }
    )
    
    prog = session.get(Programme, pre.programme_id)
    return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&pre_id={pre.id}&success=infos_updated", status_code=303)


# Recalcul eligibilit√©
@router.post("/eligibilite/recalc", name="eligibilite_recalc")
def elig_recalc(
    request: Request,
    pre_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    try:
        print(f"üîÑ [RECALC] D√©but recalcul √©ligibilit√© pour pr√©inscription {pre_id}")
        pre = session.get(Preinscription, pre_id)
        
        if not pre:
            print(f"‚ùå [RECALC] Pr√©inscription {pre_id} introuvable")
            raise HTTPException(status_code=404, detail="Pr√©inscription introuvable")
        
        prog = session.get(Programme, pre.programme_id)
        if not prog:
            print(f"‚ùå [RECALC] Programme {pre.programme_id} introuvable")
            raise HTTPException(status_code=404, detail="Programme introuvable")
        
        cand = session.get(Candidat, pre.candidat_id)
        if not cand:
            print(f"‚ùå [RECALC] Candidat {pre.candidat_id} introuvable")
            raise HTTPException(status_code=404, detail="Candidat introuvable")
        
        ent = session.exec(select(Entreprise).where(Entreprise.candidat_id==cand.id)).first()
        if not ent:
            print(f"‚ùå [RECALC] Entreprise pour candidat {cand.id} introuvable")
            raise HTTPException(status_code=404, detail="Entreprise introuvable")

        print(f"üìä [RECALC] Donn√©es trouv√©es - CA: {ent.chiffre_affaires}, Date cr√©ation: {ent.date_creation}")
        
        ca = ent.chiffre_affaires
        anc = entreprise_age_annees(ent.date_creation)
        
        print(f"üîç [RECALC] Calcul anciennet√©: {anc} ans")
        
        verdict, details = evaluate_eligibilite(
            adresse_perso=cand.adresse_personnelle,
            adresse_entreprise=ent.adresse,
            chiffre_affaires=ca,
            anciennete_annees=anc,
            ca_min=prog.ca_seuil_min,
            ca_max=prog.ca_seuil_max,
            anciennete_min_annees=prog.anciennete_min_annees
        )
        
        print(f"‚úÖ [RECALC] √âvaluation termin√©e - Verdict: {verdict}, Details: {details}")
        
        elig = session.exec(select(Eligibilite).where(Eligibilite.preinscription_id==pre.id)).first()
        if not elig:
            print(f"üÜï [RECALC] Cr√©ation nouvelle √©ligibilit√©")
            elig = Eligibilite(preinscription_id=pre.id)
            session.add(elig)
        
        elig.ca_seuil_ok = details.get("ca_ok")
        elig.ca_score = None  # Pas de valeur num√©rique unique pour les intervalles
        elig.qpv_ok = details.get("qpv_ok")
        elig.anciennete_ok = details.get("anciennete_ok")
        elig.anciennete_annees = details.get("anciennete_annees")
        elig.verdict = verdict
        session.commit()
        
        print(f"üéâ [RECALC] Recalcul termin√© avec succ√®s")
        return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&pre_id={pre.id}", status_code=303)
        
    except Exception as e:
        print(f"‚ùå [RECALC] Erreur lors du recalcul: {e}")
        session.rollback()
        raise HTTPException(status_code=500, detail=f"Erreur lors du recalcul: {str(e)}")


# Ajouter un document
@router.post("/add-document", name="add_document_inscription")
async def add_document(
    request: Request,
    candidat_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    type_document: str = Form(...),
    document_file: UploadFile = File(...),
    description: Optional[str] = Form(None),
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    try:
        print(f"üìÑ [DOC] Ajout document pour candidat {candidat_id}")
        
        # V√©rifier que le candidat existe
        candidat = session.get(Candidat, candidat_id)
        if not candidat:
            raise HTTPException(status_code=404, detail="Candidat introuvable")
        
        # Valider le fichier
        if not document_file.filename:
            raise HTTPException(status_code=400, detail="Aucun fichier s√©lectionn√©")
        
        # V√©rifier la taille (10MB max)
        file_content = document_file.file.read()
        if len(file_content) > 10 * 1024 * 1024:  # 10MB
            raise HTTPException(status_code=400, detail="Fichier trop volumineux (max 10MB)")
        
        # V√©rifier l'extension
        file_ext = os.path.splitext(document_file.filename)[1].lower() or ".pdf"
        allowed_extensions = ['.pdf', '.doc', '.docx', '.jpg', '.jpeg', '.png']
        if file_ext not in allowed_extensions:
            raise HTTPException(status_code=400, detail="Format de fichier non autoris√©")
        
        # Pr√©parer le r√©pertoire de sauvegarde sp√©cifique au candidat
        subfolder = f"documents/candidat_{candidat_id}"
        
        # Cr√©er le nom de fichier unique bas√© sur le type et l'ID candidat
        file_ext = os.path.splitext(document_file.filename)[1].lower() or ".pdf"
        base_filename = f"{type_document.lower()}_{candidat_id}{file_ext}"
        
        # Utiliser FileUploadService pour sauvegarder le fichier
        file_info = await FileUploadService.save_file(
            document_file,
            "files",
            base_filename,
            subfolder=subfolder
        )
        
        print(f"üìÑ [DOC] Fichier sauvegard√©: {file_info['relative_path']}")
        
        # Cr√©er l'enregistrement en base
        from app_lia_web.app.models.base import Document
        from app_lia_web.app.models.enums import TypeDocument
        
        doc = Document(
            candidat_id=candidat_id,
            nom_fichier=document_file.filename,
            chemin_fichier=file_info["relative_path"],
            taille_octets=file_info["size"],
            type_document=TypeDocument(type_document) if type_document in [e.value for e in TypeDocument] else TypeDocument.AUTRE,
            description=description,
            date_upload=datetime.now(timezone.utc)
        )
        
        session.add(doc)
        session.commit()
        
        print(f"‚úÖ [DOC] Document ajout√© avec succ√®s: {file_info['relative_path']}")
        
        # Rediriger vers la page avec un message de succ√®s
        preinscription = session.exec(select(Preinscription).where(Preinscription.candidat_id == candidat_id)).first()
        if preinscription:
            programme = session.get(Programme, preinscription.programme_id)
            return RedirectResponse(
                url=f"{request.url_for('form_inscriptions_display')}?programme={programme.code}&pre_id={preinscription.id}&success=document_added",
                status_code=303
            )
        else:
            return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&success=document_added", status_code=303)
            
    except Exception as e:
        print(f"‚ùå [DOC] Erreur lors de l'ajout: {e}")
        session.rollback()
        raise HTTPException(status_code=500, detail=f"Erreur lors de l'ajout du document: {str(e)}")


# Supprimer un document
@router.post("/delete-document", name="delete_document_inscription")
def delete_document(
    request: Request,
    document_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    try:
        print(f"üóëÔ∏è [DOC] Suppression document {document_id}")
        
        # R√©cup√©rer le document
        from app_lia_web.app.models.base import Document
        doc = session.get(Document, document_id)
        if not doc:
            return {"success": False, "error": "Document introuvable"}
        
        # Supprimer le fichier physique
        if doc.chemin_fichier and os.path.exists(doc.chemin_fichier):
            os.remove(doc.chemin_fichier)
            print(f"üóëÔ∏è [DOC] Fichier supprim√©: {doc.chemin_fichier}")
        
        # Supprimer l'enregistrement en base
        session.delete(doc)
        session.commit()
        
        print(f"‚úÖ [DOC] Document supprim√© avec succ√®s")
        
        # Rediriger vers la page avec un message de succ√®s
        preinscription = session.exec(select(Preinscription).where(Preinscription.candidat_id == doc.candidat_id)).first()
        if preinscription:
            programme = session.get(Programme, preinscription.programme_id)
            return RedirectResponse(
                url=f"{request.url_for('form_inscriptions_display')}?programme={programme.code}&pre_id={preinscription.id}&success=document_deleted",
                status_code=303
            )
        else:
            return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&success=document_deleted", status_code=303)
        
    except Exception as e:
        print(f"‚ùå [DOC] Erreur lors de la suppression: {e}")
        session.rollback()
        return {"success": False, "error": str(e)}


# Avancement d'√©tape
@router.post("/etape/advance", name="etape_advance_inscription")
def etape_advance(
    avancement_id: int = Form(...),
    statut: str = Form(...),  # A_FAIRE | EN_COURS | TERMINE
    programme: str = Form(...),  # Ajout du param√®tre programme
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    av = session.get(AvancementEtape, avancement_id)
    if not av:
        raise HTTPException(status_code=404, detail="Avancement introuvable")
    try:
        new_status = StatutEtape[statut]
    except Exception:
        raise HTTPException(status_code=400, detail="Statut invalide")

    from datetime import datetime as _dt
    av.statut = new_status
    now = _dt.utcnow()
    if new_status.name == "EN_COURS" and not av.debut_le:
        av.debut_le = now
    if new_status.name == "TERMINE":
        if not av.debut_le: av.debut_le = now
        av.termine_le = now

    session.commit()
    ins = session.get(Inscription, av.inscription_id)
    prog = session.get(Programme, ins.programme_id)
    pre = session.exec(select(Preinscription).where(Preinscription.programme_id==prog.id, Preinscription.candidat_id==ins.candidat_id)).first()
    return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code}&pre_id={pre.id if pre else ''}", status_code=303)


# --------- GESTION DES D√âCISIONS DU JURY ---------
@router.post("/jury/decision", name="create_jury_decision_inscription")
def create_jury_decision(
    request: Request,
    candidat_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    jury_id: Optional[int] = Form(None),
    decision: str = Form(...),
    commentaires: Optional[str] = Form(None),
    conseiller_id: Optional[str] = Form(None), # Chang√© de Optional[int] √† Optional[str]
    groupe_id: Optional[str] = Form(None),
    promotion_id: Optional[str] = Form(None),
    partenaire_id: Optional[str] = Form(None),
    envoyer_mail_candidat: bool = Form(False),
    envoyer_mail_conseiller: bool = Form(False),
    envoyer_mail_partenaire: bool = Form(False),
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """Cr√©er une d√©cision du jury"""
    
    print(f"üìã [JURY] Donn√©es re√ßues:")
    print(f"   - candidat_id: {candidat_id} (type: {type(candidat_id)})")
    print(f"   - jury_id: {jury_id} (type: {type(jury_id)})")
    print(f"   - decision: {decision} (type: {type(decision)})")
    print(f"   - commentaires: {commentaires} (type: {type(commentaires)})")
    print(f"   - conseiller_id: {conseiller_id} (type: {type(conseiller_id)})")
    print(f"   - promotion_id: {promotion_id} (type: {type(promotion_id)})")
    print(f"   - partenaire_id: {partenaire_id} (type: {type(partenaire_id)})")
    
    # Convertir les cha√Ænes vides en None pour les IDs
    def safe_int_convert(value):
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, str) and value.strip():
            try:
                return int(value)
            except ValueError:
                return None
        return None
    
    promotion_id_int = safe_int_convert(promotion_id)
    partenaire_id_int = safe_int_convert(partenaire_id)
    conseiller_id_int = safe_int_convert(conseiller_id)
    groupe_id_int = safe_int_convert(groupe_id)
    
    # V√©rifier que le groupe existe (si fourni)
    groupe = None
    if groupe_id_int:
        groupe = session.get(Groupe, groupe_id_int)
        if not groupe:
            print(f"‚ö†Ô∏è [JURY] Groupe introuvable: {groupe_id}")
            groupe_id_int = None
    
    print(f"üìã [JURY] IDs convertis:")
    print(f"   - promotion_id_int: {promotion_id_int}")
    print(f"   - partenaire_id_int: {partenaire_id_int}")
    print(f"   - conseiller_id_int: {conseiller_id_int}")
    print(f"   - groupe_id_int: {groupe_id_int}")
    
    # V√©rifier que le candidat existe
    candidat = session.get(Candidat, candidat_id)
    if not candidat:
        raise HTTPException(status_code=404, detail="Candidat introuvable")
    
    # V√©rifier que le jury existe (si fourni)
    jury = None
    if jury_id:
        jury = session.get(Jury, jury_id)
        if not jury:
            raise HTTPException(status_code=404, detail="Jury introuvable")
    
    # V√©rifier qu'il n'y a pas d√©j√† une d√©cision pour ce candidat et ce jury
    existing = session.exec(
        select(DecisionJuryCandidat).where(
            (DecisionJuryCandidat.candidat_id == candidat_id) &
            (DecisionJuryCandidat.jury_id == jury_id)
        )
    ).first()
    
    if existing:
        raise HTTPException(status_code=400, detail="Une d√©cision existe d√©j√† pour ce candidat et ce jury")
    
    # Cr√©er la d√©cision
    decision_obj = DecisionJuryCandidat(
        candidat_id=candidat_id,
        jury_id=jury_id,
        decision=DecisionJury(decision),
        commentaires=commentaires,
        conseiller_id=conseiller_id_int if decision == DecisionJury.VALIDE.value else None,
        groupe_id=groupe_id_int if decision == DecisionJury.VALIDE.value else None,
        promotion_id=promotion_id_int if decision == DecisionJury.VALIDE.value else None,
        partenaire_id=partenaire_id_int if decision == DecisionJury.REORIENTE.value else None,
        envoyer_mail_candidat=envoyer_mail_candidat,
        envoyer_mail_conseiller=envoyer_mail_conseiller,
        envoyer_mail_partenaire=envoyer_mail_partenaire,
    )
    
    session.add(decision_obj)
    session.flush()
    
    # Mettre √† jour le statut du candidat
    candidat.statut = decision
    
    # Si r√©orient√©, cr√©er l'enregistrement de r√©orientation
    if decision == DecisionJury.REORIENTE.value and partenaire_id:
        reorientation = ReorientationCandidat(
            candidat_id=candidat_id,
            partenaire_id=partenaire_id,
            decision_jury_id=decision_obj.id,
            mail_envoye=envoyer_mail_partenaire,
        )
        session.add(reorientation)
    
    session.commit()
    
    # TODO: Envoyer les emails selon les cases coch√©es
    if envoyer_mail_candidat or envoyer_mail_conseiller or envoyer_mail_partenaire:
        # Logique d'envoi d'emails √† impl√©menter
        pass
    
    # Log de l'activit√©
    from app_lia_web.app.services.ACD.audit import log_activity
    log_activity(
        session=session,
        user=current_user,
        action="D√©cision jury cr√©√©e",
        entity="DecisionJuryCandidat",
        entity_id=decision_obj.id,
        activity_data={
            "candidat_id": candidat_id,
            "jury_id": jury_id,
            "decision": decision,
            "emails_envoyes": {
                "candidat": envoyer_mail_candidat,
                "conseiller": envoyer_mail_conseiller,
                "partenaire": envoyer_mail_partenaire,
            }
        }
    )
    
    # Redirection vers la page d'inscription
    prog = session.exec(select(Programme).join(Preinscription).where(Preinscription.candidat_id == candidat_id)).first()
    pre = session.exec(select(Preinscription).where(Preinscription.candidat_id == candidat_id)).first()
    return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code if prog else 'ACD'}&pre_id={pre.id if pre else ''}&success=decision_created", status_code=303)


@router.post("/jury/decision/{decision_id}/delete", name="delete_jury_decision_inscription")
def delete_jury_decision(
    request: Request,
    decision_id: int,
    programme: str = Form(...),  # Ajout du param√®tre programme
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """Supprimer une d√©cision du jury"""
    
    decision_obj = session.get(DecisionJuryCandidat, decision_id)
    if not decision_obj:
        raise HTTPException(status_code=404, detail="D√©cision introuvable")
    
    candidat_id = decision_obj.candidat_id
    
    # Remettre le candidat en attente
    candidat = session.get(Candidat, candidat_id)
    if candidat:
        candidat.statut = DecisionJury.EN_ATTENTE.value
    
    # Supprimer les r√©orientations associ√©es
    session.exec(
        select(ReorientationCandidat).where(
            ReorientationCandidat.decision_jury_id == decision_id
        )
    )
    
    session.delete(decision_obj)
    session.commit()
    
    # Log de l'activit√©
    from app_lia_web.app.services.ACD.audit import log_activity
    log_activity(
        session=session,
        user=current_user,
        action="D√©cision jury supprim√©e",
        entity="DecisionJuryCandidat",
        entity_id=decision_id,
        activity_data={
            "candidat_id": candidat_id,
        }
    )
    
    # Redirection vers la page d'inscription
    prog = session.exec(select(Programme).join(Preinscription).where(Preinscription.candidat_id == candidat_id)).first()
    pre = session.exec(select(Preinscription).where(Preinscription.candidat_id == candidat_id)).first()
    return RedirectResponse(url=f"{request.url_for('form_inscriptions_display')}?programme={prog.code if prog else 'ACD'}&pre_id={pre.id if pre else ''}&success=decision_deleted", status_code=303)


# --------- INT√âGRATION QPV ET SIRET ---------
@router.post("/qpv-check", name="check_qpv_candidate_inscription")
async def check_qpv_candidate(
    candidat_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    adresse_personnelle: Optional[str] = Form(None),
    adresse_entreprise: Optional[str] = Form(None),
    request: Request = None,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """V√©rifier le statut QPV pour un candidat en analysant son adresse personnelle et celle de l'entreprise"""
    
    candidat = session.get(Candidat, candidat_id)
    if not candidat:
        raise HTTPException(status_code=404, detail="Candidat introuvable")
    
    # R√©cup√©rer les adresses depuis la base si non fournies
    if not adresse_personnelle or not adresse_entreprise:
        entreprise = session.exec(select(Entreprise).where(Entreprise.candidat_id == candidat_id)).first()
        
        # Adresse personnelle du candidat
        if not adresse_personnelle:
            adresse_personnelle = candidat.adresse_personnelle
        
        # Adresse de l'entreprise
        if not adresse_entreprise and entreprise:
            adresse_entreprise = entreprise.adresse
    
    # üîç V√âRIFICATION PR√âALABLE : Recherche existante ?
    preinscription = session.exec(
        select(Preinscription).where(Preinscription.candidat_id == candidat_id)
    ).first()
    
    if preinscription:
        eligibilite = session.exec(
            select(Eligibilite).where(Eligibilite.preinscription_id == preinscription.id)
        ).first()
        
        # Si une v√©rification QPV existe d√©j√† et les adresses n'ont pas chang√©
        if eligibilite and eligibilite.qpv_ok is not None and eligibilite.details_json:
            try:
                import json
                import ast
                
                print(f"üîç [QPV] Donn√©es existantes trouv√©es pour candidat {candidat_id}")
                print(f"üîç [QPV] QPV OK: {eligibilite.qpv_ok}")
                
                # Essayer de parser le JSON
                try:
                    details_existants = json.loads(eligibilite.details_json)
                    print(f"üîç [QPV] JSON pars√© avec succ√®s")
                except json.JSONDecodeError:
                    # Si JSON √©choue, essayer de parser comme un dict Python (ancien format)
                    try:
                        details_existants = ast.literal_eval(eligibilite.details_json)
                        print(f"üîç [QPV] Dict Python pars√© avec succ√®s (ancien format)")
                    except (ValueError, SyntaxError) as e:
                        print(f"‚ùå [QPV] Impossible de parser les donn√©es en cache: {e}")
                        raise
                
                # V√©rifier si les adresses correspondent
                adresses_existantes = details_existants.get("adresses_analysees", [])
                print(f"üîç [QPV] Adresses en cache: {len(adresses_existantes)}")
                
                if adresses_existantes:
                    # Comparer les adresses (simplifi√©)
                    adresse_existante_perso = adresses_existantes[0].get("adresse", "") if len(adresses_existantes) > 0 else ""
                    adresse_existante_ent = adresses_existantes[1].get("adresse", "") if len(adresses_existantes) > 1 else ""
                    
                    print(f"üîç [QPV] Comparaison adresses:")
                    print(f"   - Personnelle: '{adresse_personnelle}' vs '{adresse_existante_perso}'")
                    print(f"   - Entreprise: '{adresse_entreprise}' vs '{adresse_existante_ent}'")
                    
                    # Comparaison plus flexible (ignore les espaces en d√©but/fin)
                    perso_match = adresse_personnelle.strip() == adresse_existante_perso.strip() if adresse_personnelle else adresse_existante_perso == "Non disponible"
                    ent_match = adresse_entreprise.strip() == adresse_existante_ent.strip() if adresse_entreprise else adresse_existante_ent == "Non disponible"
                    
                    if perso_match and ent_match:
                        print(f"‚úÖ [QPV] Utilisation des donn√©es existantes pour candidat {candidat_id}")
                        return {
                            "candidat_id": candidat_id,
                            "adresses_analysees": adresses_existantes,
                            "statut_qpv_final": "QPV" if eligibilite.qpv_ok else "NON_QPV",
                            "details": details_existants,
                            "from_cache": True
                        }
                    else:
                        print(f"‚ö†Ô∏è [QPV] Adresses diff√©rentes, nouvelle recherche n√©cessaire")
                else:
                    print(f"‚ö†Ô∏è [QPV] Aucune adresse en cache")
            except (json.JSONDecodeError, KeyError, IndexError, ValueError, SyntaxError) as e:
                print(f"‚ùå [QPV] Erreur lors de la lecture du cache: {e}")
                pass  # Continuer avec une nouvelle recherche
        else:
            print(f"‚ö†Ô∏è [QPV] Pas de donn√©es en cache - eligibilite: {bool(eligibilite)}, qpv_ok: {eligibilite.qpv_ok if eligibilite else None}")
    
    # Si pas de donn√©es existantes ou adresses diff√©rentes, lancer la recherche
    print(f"üîç [QPV] Lancement nouvelle recherche pour candidat {candidat_id}")
    
    results = {
        "candidat_id": candidat_id,
        "adresses_analysees": [],
        "statut_qpv_final": "NON_QPV",
        "details": {}
    }
    
    # Analyser l'adresse personnelle du candidat si disponible
    print(f"üîç [QPV] Adresse personnelle re√ßue: '{adresse_personnelle}'")
    if adresse_personnelle and adresse_personnelle.strip():
        try:
            print(f"üîç [QPV] Analyse adresse personnelle: {adresse_personnelle}")
            qpv_personnelle = await verif_qpv({"address": adresse_personnelle}, request)
            results["adresses_analysees"].append({
                "type": "personnelle",
                "adresse": adresse_personnelle,
                "resultat": qpv_personnelle
            })
            results["details"]["personnelle"] = qpv_personnelle
            print(f"‚úÖ [QPV] Adresse personnelle analys√©e avec succ√®s")
        except Exception as e:
            print(f"‚ùå [QPV] Erreur analyse adresse personnelle: {e}")
            results["adresses_analysees"].append({
                "type": "personnelle",
                "adresse": adresse_personnelle,
                "erreur": str(e)
            })
    else:
        print(f"‚ö†Ô∏è [QPV] Adresse personnelle vide ou non fournie")
        results["adresses_analysees"].append({
            "type": "personnelle",
            "adresse": "Non disponible",
            "non_disponible": True
        })
    
    # Analyser l'adresse de l'entreprise si disponible
    print(f"üîç [QPV] Adresse entreprise re√ßue: '{adresse_entreprise}'")
    if adresse_entreprise and adresse_entreprise.strip():
        try:
            print(f"üîç [QPV] Analyse adresse entreprise: {adresse_entreprise}")
            qpv_entreprise = await verif_qpv({"address": adresse_entreprise}, request)
            results["adresses_analysees"].append({
                "type": "entreprise",
                "adresse": adresse_entreprise,
                "resultat": qpv_entreprise
            })
            results["details"]["entreprise"] = qpv_entreprise
            print(f"‚úÖ [QPV] Adresse entreprise analys√©e avec succ√®s")
        except Exception as e:
            print(f"‚ùå [QPV] Erreur analyse entreprise: {e}")
            results["adresses_analysees"].append({
                "type": "entreprise",
                "adresse": adresse_entreprise,
                "erreur": str(e)
            })
    else:
        print(f"‚ö†Ô∏è [QPV] Adresse entreprise vide ou non fournie")
        results["adresses_analysees"].append({
            "type": "entreprise",
            "adresse": "Non disponible",
            "non_disponible": True
        })
    
    # D√©terminer le statut QPV final
    qpv_found = False
    for analyse in results["adresses_analysees"]:
        if "resultat" in analyse:
            nom_qp = analyse["resultat"].get("nom_qp", "")
            if "QPV:" in nom_qp or "QPV limit:" in nom_qp:
                qpv_found = True
                results["statut_qpv_final"] = "QPV"
                break
    
    # Mettre √† jour l'√©ligibilit√© du candidat
    if candidat:
        preinscription = session.exec(
            select(Preinscription).where(Preinscription.candidat_id == candidat_id)
        ).first()
        
        if preinscription:
            eligibilite = session.exec(
                select(Eligibilite).where(Eligibilite.preinscription_id == preinscription.id)
            ).first()
            
            if not eligibilite:
                eligibilite = Eligibilite(preinscription_id=preinscription.id)
                session.add(eligibilite)
            
            import json
            eligibilite.qpv_ok = qpv_found
            eligibilite.details_json = json.dumps(results)  # Sauvegarder results complet, pas seulement details
            session.add(eligibilite)
            session.commit()
            
            print(f"‚úÖ [QPV] √âligibilit√© mise √† jour - QPV: {qpv_found}")
    
    # Log de l'activit√©
    from app_lia_web.app.services.ACD.audit import log_activity
    log_activity(
        session=session,
        user=current_user,
        action="V√©rification QPV candidat",
        entity="Candidat",
        entity_id=candidat_id,
        activity_data={
            "statut_qpv": results["statut_qpv_final"],
            "adresses_analysees": len(results["adresses_analysees"]),
            "details": results["details"]
        }
    )
    
    print(f"üîç [QPV] R√©sultat final: {len(results['adresses_analysees'])} adresses analys√©es")
    print(f"üîç [QPV] Statut final: {results['statut_qpv_final']}")
    
    return results


@router.post("/siret-check", name="check_siret_candidate_inscription")
async def check_siret_candidate(
    candidat_id: int = Form(...),
    programme: str = Form(...),  # Ajout du param√®tre programme
    numero_siret: str = Form(...),
    request: Request = None,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """V√©rifier les informations SIRET pour un candidat"""
    
    candidat = session.get(Candidat, candidat_id)
    if not candidat:
        raise HTTPException(status_code=404, detail="Candidat introuvable")
    
    try:
        print(f"üîç [SIRET] Recherche SIRET: {numero_siret}")
        
        # Valider le format SIRET
        siret_request = SiretRequest(numero_siret=numero_siret)
        
        # Appeler le service SIRET
        siret_info = await get_entreprise_process(siret_request.numero_siret[:9], request)
        
        # Mettre √† jour les informations de l'entreprise
        entreprise = session.exec(
            select(Entreprise).where(Entreprise.candidat_id == candidat_id)
        ).first()
        
        if not entreprise:
            entreprise = Entreprise(candidat_id=candidat_id)
            session.add(entreprise)
        
        if siret_info.get("entreprise_data"):
            data = siret_info["entreprise_data"]
            
            # Mettre √† jour les champs de l'entreprise
            entreprise.siret = data.get("siege", {}).get("siret")
            entreprise.siren = data.get("siren")
            entreprise.raison_sociale = data.get("nom_entreprise")  # Utiliser raison_sociale au lieu de nom_entreprise
            entreprise.code_naf = data.get("code_naf")
            entreprise.date_creation = data.get("date_creation")
            
            # Mettre √† jour l'adresse du si√®ge
            siege = data.get("siege", {})
            entreprise.adresse = siege.get("adresse")
            entreprise.lat = siege.get("latitude")
            entreprise.lng = siege.get("longitude")
            
            session.add(entreprise)
            session.commit()
            
            print(f"‚úÖ [SIRET] Informations entreprise mises √† jour")
        
        # Log de l'activit√©
        from app_lia_web.app.services.ACD.audit import log_activity
        log_activity(
            session=session,
            user=current_user,
            action="V√©rification SIRET candidat",
            entity="Candidat",
            entity_id=candidat_id,
            activity_data={
                "numero_siret": numero_siret,
                "entreprise_trouvee": bool(siret_info.get("entreprise_data")),
                "status_code": siret_info.get("status_code")
            }
        )
        
        return {
            "candidat_id": candidat_id,
            "numero_siret": numero_siret,
            "resultat": siret_info,
            "entreprise_mise_a_jour": bool(siret_info.get("entreprise_data"))
        }
        
    except Exception as e:
        print(f"‚ùå [SIRET] Erreur: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la v√©rification SIRET: {str(e)}")


@router.get("/qpv-status/{candidat_id}", name="get_qpv_status_inscription")
def get_qpv_status(
    candidat_id: int,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """R√©cup√©rer le statut QPV actuel d'un candidat"""
    
    candidat = session.get(Candidat, candidat_id)
    if not candidat:
        raise HTTPException(status_code=404, detail="Candidat introuvable")
    
    # R√©cup√©rer l'√©ligibilit√©
    preinscription = session.exec(
        select(Preinscription).where(Preinscription.candidat_id == candidat_id)
    ).first()
    
    if not preinscription:
        return {"statut_qpv": "NON_DETERMINE", "details": None}
    
    eligibilite = session.exec(
        select(Eligibilite).where(Eligibilite.preinscription_id == preinscription.id)
    ).first()
    
    if not eligibilite:
        return {"statut_qpv": "NON_DETERMINE", "details": None}
    
    return {
        "statut_qpv": "QPV" if eligibilite.qpv_ok else "NON_QPV",
        "details": eligibilite.details_json,
        "derniere_verification": eligibilite.cree_le
    }


@router.post("/download-siret-document", name="download_siret_document_inscription")
async def download_siret_document(
    request: Request,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """T√©l√©charge un document depuis l'API SIRET et l'ajoute aux documents du candidat"""
    try:
        data = await request.json()
        candidat_id = data.get("candidat_id")
        token = data.get("token")
        nom_fichier = data.get("nom_fichier", "document_siret.pdf")
        type_document = data.get("type_document", "AUTRE")
        
        if not candidat_id or not token:
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": "Candidat ID et token requis"}
            )
        
        # V√©rifier que le token n'est pas vide
        if not token.strip():
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": "Token de t√©l√©chargement invalide"}
            )
        
        # V√©rifier que le candidat existe
        candidat = session.query(Candidat).filter(Candidat.id == candidat_id).first()
        if not candidat:
            return JSONResponse(
                status_code=404,
                content={"success": False, "message": "Candidat non trouv√©"}
            )
        
        # V√©rifier que l'API key Pappers est configur√©e
        if not settings.PAPPERS_API_KEY:
            return JSONResponse(
                status_code=500,
                content={"success": False, "message": "API key Pappers non configur√©e"}
            )
        
        # T√©l√©charger le document depuis l'API Pappers
        import requests
        pappers_url = f"https://api.pappers.fr/v2/document/telechargement?token={token}&api_token={settings.PAPPERS_API_KEY}"
        
        print(f"üì• [SIRET DOC] T√©l√©chargement depuis: {pappers_url}")
        print(f"üîë [SIRET DOC] Token utilis√©: {token[:20]}...")
        print(f"üîë [SIRET DOC] API key utilis√©e: {settings.PAPPERS_API_KEY[:10]}...")
        
        response = requests.get(pappers_url, timeout=30)
        print(f"üìä [SIRET DOC] Status code: {response.status_code}")
        print(f"üìä [SIRET DOC] Headers: {dict(response.headers)}")
        
        if response.status_code != 200:
            print(f"‚ùå [SIRET DOC] Erreur t√©l√©chargement: {response.status_code}")
            print(f"‚ùå [SIRET DOC] R√©ponse: {response.text[:200]}")
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": f"Erreur lors du t√©l√©chargement du document (HTTP {response.status_code})"}
            )
        
        # Pr√©parer le r√©pertoire de sauvegarde
        candidat_dir = settings.FICHIERS_DIR / "documents" / f"candidat_{candidat_id}"
        candidat_dir.mkdir(parents=True, exist_ok=True)
        
        # Cr√©er un nom de fichier unique
        file_ext = ".pdf"  # Les documents SIRET sont g√©n√©ralement des PDF
        base_filename = f"siret_{type_document.lower()}_{candidat_id}{file_ext}"
        unique_filename = base_filename
        
        # V√©rifier si le fichier existe d√©j√† et ajouter un suffixe num√©rique si n√©cessaire
        counter = 1
        while (candidat_dir / unique_filename).exists():
            name_without_ext = f"siret_{type_document.lower()}_{candidat_id}"
            unique_filename = f"{name_without_ext}_{counter}{file_ext}"
            counter += 1
        
        file_path = candidat_dir / unique_filename
        
        # Sauvegarder le fichier
        with open(file_path, "wb") as f:
            f.write(response.content)
        
        print(f"‚úÖ [SIRET DOC] Fichier sauvegard√©: {file_path}")
        
        # Cr√©er l'enregistrement en base de donn√©es
        document = Document(
            candidat_id=candidat_id,
            nom_fichier=unique_filename,
            chemin_fichier=str(file_path.relative_to(settings.FICHIERS_DIR)),
            type_document="AUTRE",  # Utiliser AUTRE temporairement
            taille_octets=len(response.content),
            depose_le=datetime.now(timezone.utc)
        )
        
        session.add(document)
        session.commit()
        session.refresh(document)
        
        print(f"‚úÖ [SIRET DOC] Document enregistr√© en base: ID {document.id}")
        print(f"üìã [SIRET DOC] D√©tails du document:")
        print(f"   - Candidat ID: {document.candidat_id}")
        print(f"   - Nom fichier: {document.nom_fichier}")
        print(f"   - Type document: {document.type_document}")
        print(f"   - Chemin: {document.chemin_fichier}")
        print(f"   - Taille: {document.taille_octets} bytes")
        
        # V√©rification imm√©diate que le document existe en base
        verification = session.exec(select(Document).where(Document.id == document.id)).first()
        if verification:
            print(f"‚úÖ [SIRET DOC] V√©rification OK: Document {document.id} trouv√© en base")
        else:
            print(f"‚ùå [SIRET DOC] ERREUR: Document {document.id} non trouv√© en base")
        
        return JSONResponse(
            status_code=200,
            content={
                "success": True, 
                "message": f"Document '{nom_fichier}' t√©l√©charg√© et ajout√© avec succ√®s",
                "document_id": document.id,
                "filename": unique_filename
            }
        )
        
    except Exception as e:
        print(f"‚ùå [SIRET DOC] Erreur: {str(e)}")
        session.rollback()
        return JSONResponse(
            status_code=500,
            content={"success": False, "message": f"Erreur lors du traitement: {str(e)}"}
        )

# Routes pour servir les fichiers documents
@router.get("/document/{document_id}/view", name="inscriptions_document_view")
def view_document(
    document_id: int,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """Afficher un document dans le navigateur."""
    try:
        from app_lia_web.app.models.base import Document
        
        doc = session.get(Document, document_id)
        if not doc:
            raise HTTPException(status_code=404, detail="Document introuvable")
        
        # Construire le chemin complet du fichier
        file_path = settings.FICHIERS_DIR / doc.chemin_fichier
        
        if not file_path.exists():
            print(f"‚ùå [DOC] Fichier non trouv√©: {file_path}")
            raise HTTPException(status_code=404, detail="Fichier introuvable")
        
        # D√©terminer le type MIME
        import mimetypes
        mime_type, _ = mimetypes.guess_type(str(file_path))
        if not mime_type:
            mime_type = "application/octet-stream"
        
        # Lire le fichier
        with open(file_path, "rb") as f:
            content = f.read()
        
        from fastapi.responses import Response
        return Response(
            content=content,
            media_type=mime_type,
            headers={
                "Content-Disposition": f"inline; filename={doc.nom_fichier}",
                "Content-Length": str(len(content))
            }
        )
        
    except Exception as e:
        print(f"‚ùå [DOC] Erreur lors de l'affichage: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de l'affichage du document: {str(e)}")


@router.get("/document/{document_id}/download", name="inscriptions_document_download")
def download_document(
    document_id: int,
    session: Session = Depends(get_session),
    current_user=Depends(get_current_user),
):
    """T√©l√©charger un document."""
    try:
        from app_lia_web.app.models.base import Document
        from fastapi.responses import FileResponse
        
        doc = session.get(Document, document_id)
        if not doc:
            raise HTTPException(status_code=404, detail="Document introuvable")
        
        # Construire le chemin complet du fichier
        file_path = path_config.get_physical_path("files", doc.chemin_fichier)
        
        if not file_path.exists():
            print(f"‚ùå [DOC] Fichier non trouv√©: {file_path}")
            raise HTTPException(status_code=404, detail="Fichier introuvable")
        
        return FileResponse(
            path=str(file_path),
            filename=doc.nom_fichier,
            media_type="application/octet-stream"
        )
        
    except Exception as e:
        print(f"‚ùå [DOC] Erreur lors du t√©l√©chargement: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur lors du t√©l√©chargement du document: {str(e)}")
